# 99-solutions

These are my solutions to the 99-problems in differents languagues

## 99-problems
[Original Prolog list and more details about the problems](https://sites.google.com/site/prologsite/prolog-problems/1)

1. Lists
   * 1.01 (*) Find the last element of a list
   * 1.02 (*) Find the last but one element of a list
   * 1.03 (*) Find the K'th element of a list
   * 1.04 (*) Find the number of elements of a list
   * 1.05 (*) Reverse a list
   * 1.06 (*) Find out whether a list is a palindrome.
   * 1.07 (**) Flatten a nested list structure. (recursively)
   * 1.08 (**) Eliminate consecutive duplicates of list elements.
   * 1.09 (**) Pack consecutive duplicates of list elements into sublists.
   * 1.10 (*) Run-length encoding of a list. 
   * 1.11 (*) Modified run-length encoding.
   * 1.12 (**) Decode a run-length encoded list.
   * 1.13 (**) Run-length encoding of a list (direct solution).
   * 1.14 (*) Duplicate the elements of a list.
   * 1.15 (**) Duplicate the elements of a list a given number of times.
    * 1.16 (**) Drop every N'th element from a list.
    * 1.17 (*) Split a list into two parts; the length of the first part is given.
    * 1.18 (**) Extract a slice from a list.
    * 1.19 (**) Rotate a list N places to the left.
    * 1.20 (*) Remove the K'th element from a list.
    * 1.21 (*) Insert an element at a given position into a list.
    * 1.22 (*) Create a list containing all integers within a given range.
    * 1.23 (**) Extract a given number of randomly selected elements from a list.
    * 1.24 (*) Lotto: Draw N different random numbers from the set 1. to M.
    * 1.25 (*) Generate a random permutation of the elements of a list.
    * 1.26 (**) Generate the combinations of K distinct objects chosen from the N elements of a list
    * 1.27 (**) Group the elements of a set into disjoint subsets. 
    * 1.28 (**) Sorting a list of lists according to length of sublists
    * 
2. Arithmetic
   * 2.01 (**) Determine whether a given integer number is prime.
   * 2.02 (**) Determine the prime factors of a given positive integer.
   * 2.03 (**) Determine the prime factors of a given positive integer (2).
   * 2.04 (*) A list of prime numbers.
   * 2.05 (**) Goldbach's conjecture.
   * 2.06 (**) A list of Goldbach compositions.
   * 2.07 (**) Determine the greatest common divisor of two positive integer numbers. 
   * 2.08 (*) Determine whether two positive integer numbers are coprime. 
   * 2.09 (**) Calculate Euler's totient function phi(m).
   * 2.10 (**) Calculate Euler's totient function phi(m) (2) (improved).
   * 2.11 (*) Compare the two methods of calculating Euler's totient function. (efficiency)
3. Logic and codes
    * 3.01 (**) Truth tables for logical expressions.
    * 3.02 (*) Truth tables for logical expressions (2).
    * 3.03 (**) Truth tables for logical expressions (3).
    * 3.04 (**) Gray code.
    * 3.05 (***) Huffman code. 
4. Binary Trees
   * 4.01 (*) Check whether a given term represents a binary tree
   * 4.02 (**) Construct completely balanced binary trees
   * 4.03 (**) Symmetric binary trees
   * 4.04 (**) Binary search trees (dictionaries)
   * 4.05 (**) Generate-and-test paradigm
   * 4.06 (**) Construct height-balanced binary trees
   * 4.07 (**) Construct height-balanced binary trees with a given number of nodes
   * 4.08 (*) Count the leaves of a binary tree
   * 4.09 (*) Collect the leaves of a binary tree in a list
   * 4.10 (*) Collect the internal nodes of a binary tree in a list
   * 4.11 (*) Collect the nodes at a given level in a list
   * 4.12 (**) Construct a complete binary tree
   * 4.13 (**) Layout a binary tree (1)
   * 4.14 (**) Layout a binary tree (2)
   * 4.15 (***) Layout a binary tree (3)
   * 4.16 (**) A string representation of binary trees
   * 4.17 (**) Preorder and inorder sequences of binary trees
   * 4.18 (**) Dotstring representation of binary trees 
5. Multiway Trees
   * 5.01 (*) Check whether a given term represents a multiway tree
   * 5.02 (*) Count the nodes of a multiway tree
   * 5.03 (**) Tree construction from a node strings
   * 5.04 (*) Determine the internal path length of a tree
   * 5.05 (*) Construct the bottom-up order sequence of the tree nodes
   * 5.06 (**) Lisp-like tree representation
6. Graphs
   * 6.01 (***) Conversions
   * 6.02 (**) Path from one node to another one
   * 6.03 (*) Cycle from a given node
   * 6.04 (**) Construct all spanning trees
   * 6.05 (**) Construct the minimal spanning tree
   * 6.06 (**) Graph isomorphism
   * 6.07 (**) Node degree and graph coloration
   * 6.08 (**) Depth-first order graph traversal
   * 6.09 (**) Connected components
   * 6.10 (**) Bipartite graphs
   * 6.11 (***) Generate K-regular simple graphs with N nodes
7. Miscellaneous
   * 7.01 (**) Eight queens problem
   * 7.02 (**) Knight's tour
   * 7.03 (***) Von Koch's conjecture
   * 7.04 (***) An arithmetic puzzle
   * 7.05 (**) English number words
   * 7.06 (**) Syntax checker
   * 7.07 (**) Sudoku
   * 7.08 (***) Nonograms
   * 7.09 (***) Crossword puzzle